# Feature 23.1: Enhanced Offline Support

**Status:** Not Started
**Effort:** Large
**Phase:** 23 - Offline & Self-Service

## Overview

Full offline PWA (Progressive Web App) functionality with a sync queue. This enables employees to view their schedules and clock in/out even without internet connectivity, with automatic synchronization when connectivity is restored.

## Requirements

### Functional Requirements
- View schedule offline (cached)
- Clock in/out offline with timestamp preservation
- Queue actions for sync when online
- Conflict resolution for sync issues
- Offline indicator in UI
- Offline fallback page
- Background sync when online

### Cached Data
- User profile and settings
- Next 14 days of shifts
- Location data
- Business roles
- Recent time entries

### Offline Actions
- Clock in
- Clock out
- Start/end break
- View schedule
- View shift details

### Sync Strategy
- Immediate sync when online
- Background sync for queued actions
- Conflict detection and resolution
- User notification for sync issues

## Files

### To Create
- `app/Models/OfflineSyncQueue.php`
- `app/Services/OfflineSyncService.php`
- `app/Http/Controllers/Api/OfflineSyncController.php`
- `resources/js/service-worker.js`
- `resources/js/offline-manager.js`
- `resources/js/indexed-db.js`
- `resources/views/offline.blade.php`
- `database/migrations/xxxx_create_offline_sync_queue_table.php`
- `tests/Feature/OfflineSyncTest.php`

### To Modify
- `public/manifest.json` - PWA manifest
- `resources/views/layouts/app.blade.php` - Register service worker
- `vite.config.js` - Build service worker

### Routes
```php
Route::prefix('api/offline')->name('api.offline.')->group(function () {
    Route::get('cache-data', [OfflineSyncController::class, 'cacheData'])->name('cache-data');
    Route::post('sync', [OfflineSyncController::class, 'sync'])->name('sync');
    Route::get('sync-status/{batchId}', [OfflineSyncController::class, 'syncStatus'])->name('sync-status');
    Route::post('resolve-conflict', [OfflineSyncController::class, 'resolveConflict'])->name('resolve-conflict');
});
```

## Database Schema

### offline_sync_queue
| Column | Type | Description |
|--------|------|-------------|
| id | bigint | Primary key |
| user_id | bigint | Foreign key to users |
| tenant_id | bigint | Foreign key to tenants |
| action | string | clock_in, clock_out, break_start, break_end |
| payload | json | Action data |
| client_timestamp | timestamp | When action occurred offline |
| synced_at | timestamp | When successfully synced |
| conflict | boolean | Has sync conflict |
| conflict_data | json | Conflicting server data |
| resolution | string | How conflict was resolved |
| created_at | timestamp | |
| updated_at | timestamp | |

## Service Worker Strategy

### Caching Strategies

```javascript
// Cache-first for static assets
workbox.routing.registerRoute(
    ({request}) => request.destination === 'script' ||
                   request.destination === 'style',
    new workbox.strategies.CacheFirst()
);

// Network-first for API data
workbox.routing.registerRoute(
    ({url}) => url.pathname.startsWith('/api/'),
    new workbox.strategies.NetworkFirst({
        cacheName: 'api-cache',
        networkTimeoutSeconds: 3,
    })
);

// Stale-while-revalidate for schedule
workbox.routing.registerRoute(
    ({url}) => url.pathname.includes('/schedule'),
    new workbox.strategies.StaleWhileRevalidate()
);
```

### IndexedDB Schema

```javascript
const db = {
    stores: {
        user: { keyPath: 'id' },
        shifts: { keyPath: 'id', indexes: ['date', 'userId'] },
        locations: { keyPath: 'id' },
        syncQueue: { keyPath: 'id', autoIncrement: true },
        timeEntries: { keyPath: 'id', indexes: ['date'] },
    }
};
```

## Offline Manager

```javascript
class OfflineManager {
    // Check online status
    isOnline(): boolean;

    // Queue action for sync
    queueAction(action: string, payload: object): Promise<void>;

    // Process sync queue
    processQueue(): Promise<SyncResult>;

    // Get cached schedule
    getCachedSchedule(startDate: Date, endDate: Date): Promise<Shift[]>;

    // Handle conflict
    resolveConflict(queueId: number, resolution: string): Promise<void>;

    // Update cached data
    refreshCache(): Promise<void>;
}
```

## Conflict Resolution

### Conflict Types
1. **Clock in conflict** - Already clocked in on server
2. **Clock out conflict** - No active clock in found
3. **Time overlap** - Offline timestamp conflicts with server data

### Resolution Options
- **Keep offline** - Use offline timestamp
- **Keep server** - Discard offline action
- **Manual** - User reviews and decides

## Tasks

- [ ] Create offline_sync_queue migration
- [ ] Create OfflineSyncQueue model
- [ ] Create OfflineSyncService for processing
- [ ] Create OfflineSyncController
- [ ] Create service worker with Workbox
- [ ] Implement caching strategies
- [ ] Create IndexedDB storage layer
- [ ] Create OfflineManager JavaScript class
- [ ] Implement offline clock in/out
- [ ] Preserve timestamps from offline actions
- [ ] Create sync queue processing
- [ ] Implement conflict detection
- [ ] Create conflict resolution UI
- [ ] Add offline indicators to UI
- [ ] Create offline fallback page
- [ ] Register service worker in app
- [ ] Configure PWA manifest
- [ ] Write comprehensive tests

## Tests

Planned tests for `tests/Feature/OfflineSyncTest.php`:

1. `test_sync_endpoint_processes_queue`
2. `test_offline_clock_in_syncs_correctly`
3. `test_offline_clock_out_syncs_correctly`
4. `test_offline_timestamp_preserved`
5. `test_conflict_detected_for_duplicate_clock_in`
6. `test_conflict_resolution_keep_offline`
7. `test_conflict_resolution_keep_server`
8. `test_sync_status_returns_results`
9. `test_cache_data_returns_required_data`
10. `test_multiple_queued_actions_sync_in_order`

## JavaScript Tests

```javascript
describe('OfflineManager', () => {
    test('queues action when offline');
    test('processes queue when online');
    test('stores data in IndexedDB');
    test('retrieves cached schedule');
    test('detects online/offline status');
});
```

## Dependencies

- Workbox (service worker library)
- IndexedDB (browser storage)
- TimeEntry model
- User model
- Shift model
- PWA configuration
